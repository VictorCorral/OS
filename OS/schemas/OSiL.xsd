<?xml version="1.0" encoding="utf-8"?>
<!-- edited with XMLSpy v2008 (http://www.altova.com) by Gus Gassmann (Dalhousie University) -->
<!-- edited with XMLSPY v2004 rel. 3 U (http://www.xmlspy.com) by Jun Ma (Northwestern University) -->
<!-- schema stage stamping: experiment -> draft -> proposal -> recommendation -> finalization -> version 1.0, 1.1, 2.0, ... -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="os.optimizationservices.org" targetNamespace="os.optimizationservices.org" elementFormDefault="qualified">
	<!--OSiL.xsd: version 2.0.0 -->
	<xs:include schemaLocation="OSgL.xsd"/>
	<xs:include schemaLocation="OSnL.xsd"/>
	<xs:include schemaLocation="OSsL.xsd"/>
	<xs:element name="osil" type="OSiL"/>
	<!--OSiL: since version 1.0 -->
	<xs:complexType name="OSiL">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="instanceHeader" type="GeneralFileHeader">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="instanceData" type="InstanceData"/>
		</xs:sequence>
	</xs:complexType>
	<!--InstanceData: since version 1.0 -->
	<xs:complexType name="InstanceData">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="LinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0 - Does not use matrices. So, e.g. the expression 2x + 3y + x^2 + 2xy + 3y^2 has three quadratic coefficients: 1, 2, 3</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="specialOrderedSets" type="SpecialOrderedSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0
We use the LPSOLVE definition of SOS, which goes back to a paper by J.A.Tomlin in "Studies on Graphs and Discrete Programming", 1981. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrices" type="Matrices" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensors" type="Tensors" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="cones" type="Cones" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixProgramming" type="MatrixProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexProgramming" type="ComplexProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorProgramming" type="TensorProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!-- dead code
			<xs:element name="old_disjunctiveInformation" type="old_DisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="disjunctiveInformation" type="DisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="timeStages" type="TimeStages" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="parameters" type="Parameters" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="distributions" type="Distributions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!--			
			<xs:element name="uncertaintySets" type="UncertaintySets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<!-- dead code
			<xs:element name="stochasticData" type="StochasticData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="new_stochasticData" type="new_StochasticData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticData_mark3" type="StochasticData_mark3" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="stochasticData" type="StochasticData-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="softConstraints" type="SoftConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ambiguityResolution" type="AmbiguityResolution" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="modifications" type="InstanceModifications" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!--			
			<xs:element name="old_realTimeData" type="old_RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="realTimeData" type="RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="userFunctions" type="UserFunctions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!--			
			<xs:element name="simulations" type="Simulations" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<!--			
			<xs:element name="updateableData" type="UpdateableData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>realTimeData and simulations. experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="new_simulations" type="new_Simulations" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="xmlData" type="XMLData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--Variables: since version 1.0 -->
	<xs:complexType name="Variables">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the var child elements must agree with numberOfVariables (after "mult" has been considered)</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="Variable" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>semi-continuous (D) and semi-integer (J) types added in version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVariables" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Variable">
		<xs:annotation>
			<xs:documentation>since version 1.0. Variable type "D" (semi-continuous) and "J" (semi-integer) since 2.0.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>C - continuous
B- binary
I - integer
S - string
D - semi-continuous
J - semi-integer</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<!--Objectives: since version 1.0-->
	<xs:complexType name="Objectives">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the obj child elements must agree with numberOfObjectives (after "mult" has been considered)</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="Objective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="Objective">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number of coef child elements must match numberOfObjCoef</xs:documentation>
			</xs:annotation>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>If idx is repeated, the objective terms/coefficients are added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="maxOrMin" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="weight" type="xs:double" use="optional"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ObjCoef">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--Constraints: since version 1.0 -->
	<xs:complexType name="Constraints">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints (after "mult" has been considered)</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="Constraint" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Constraint">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<!--LinearConstraintCoefficients: since version 1.0 -->
	<xs:complexType name="LinearConstraintCoefficients">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>Number of entries in the start element must equal numberOfVariables + 1 (if columnMajor) or numberOfConstraints + 1 (if rowMajor), after considering "mult".                           Number of entries in the value and rowIdx/colIdx child elements must agree with numberOfValues (after "mult" has been considered). Multiple coefficients in the same location are added together.</xs:documentation>
			</xs:annotation>
			<xs:element name="start" type="SizelessNonNegativeIntVector"/>
			<xs:choice>
				<xs:element name="rowIdx" type="SizelessNonNegativeIntVector"/>
				<xs:element name="colIdx" type="SizelessNonNegativeIntVector"/>
			</xs:choice>
			<xs:element name="value" type="SizelessDoubleVector"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!--QuadraticCoefficients; since version 1.0 -->
	<xs:complexType name="QuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms </xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="QuadraticTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQuadraticTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="QuadraticTerm">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of the constraint or objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the first variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the second variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coef" type="xs:double" use="optional" default="1">
			<xs:annotation>
				<xs:documentation>coefficient of the
quadratic term</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--NonlinearExpressions: since version 1.0 -->
	<xs:complexType name="NonlinearExpressions">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the child nl elements must agree with numberOfNonlinearExpressions</xs:documentation>
			</xs:annotation>
			<xs:element name="nl" type="Nl" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>shape attribute added in version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfNonlinearExpressions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Nl">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of constraint or objective row</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="unknown">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="concave"/>
					<xs:enumeration value="general"/>
					<xs:enumeration value="unknown"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - -->
	<xs:complexType name="nonlinearComplexValuedExpressions">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="nonlinearComplexValuedExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="nonlinearComplexValuedExpression">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLCNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing complex-valued objectives (if negative) or complex-valued constraints (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--MatrixProgramming: proposal-->
	<xs:complexType name="MatrixProgramming">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="matrixVariables" type="MatrixVariables" minOccurs="0"/>
			<xs:element name="matrixObjectives" type="MatrixObjectives" minOccurs="0"/>
			<xs:element name="matrixConstraints" type="MatrixConstraints" minOccurs="0"/>
			<xs:element name="matrixExpressions" type="MatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For matrix-valued expressions only - scalar-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MatrixVariables">
		<xs:sequence>
			<xs:element name="matrixVar" type="MatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfMatrixVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixVar">
		<xs:sequence>
			<xs:element name="descriptor" type="MatrixVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptiors
can be used, e.g., to set up Toeplitz or Cauchy matrices</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only variables in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix variable has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core variables instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all variables indicated  by the use of the template matrix are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varType" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>same type for every newly created variable; default is 'C'; variables inherited from the core keep the type and bounds declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains varMtx - lbMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx - varMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
	</xs:complexType>
	<xs:complexType name="MatrixVarOrConDescriptor" mixed="true">
		<xs:attribute name="name" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:minLength value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="description" type="xs:string" use="optional"/>
		<xs:attribute name="value" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="MatrixObjectives">
		<xs:sequence>
			<xs:element name="matrixObj" type="MatrixObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfMatrixObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixObj">
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only objectives in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix objective has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="objReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core objectives instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all objectives indicated  by the use of the template matrix are created fresh. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>x is (weakly) preferred to y if obj(x) - obj(y) lies in cone. If reference uses only core objectives, orderConeIdx can be omitted and defaults to the corresponding orthant cone</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constantMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective;        zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="MatrixConstraints">
		<xs:sequence>
			<xs:element name="matrixCon" type="MatrixCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfMatrixCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixCon">
		<xs:sequence>
			<xs:element name="descriptor" type="MatrixVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptiors
can be used, e.g., to set up Toeplitz matrices</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only variables in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix constraint has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core constraints instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all constraints indicated  by the use of the template matrix are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains mtx expr - lbMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx -  mtx expr; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
	</xs:complexType>
	<xs:complexType name="MatrixExpressions">
		<xs:sequence>
			<xs:element name="expr" type="MatrixExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MatrixExpression">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLMNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing matrix objective (if negative) or matrix constraint (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--ComplexProgramming: experiment-->
	<xs:complexType name="ComplexProgramming">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexVariables" type="ComplexVariables" minOccurs="0"/>
			<xs:element name="complexObjectives" type="ComplexObjectives" minOccurs="0"/>
			<xs:element name="complexConstraints" type="ComplexConstraints" minOccurs="0"/>
			<xs:element name="complexExpressions" type="ComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For complex-valued expressions only - real-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ComplexVariables">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexVar" type="ComplexVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfComplexVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexVar">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains var - lb; assumed all of C if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ub - var; assumed all of C if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name"/>
		<xs:attribute name="varType" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>same type for every newly created variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ComplexObjectives">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexObj" type="ComplexObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfComplexObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexObj">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only objectives in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix objective has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="objReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core objectives instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all objectives indicated  by the use of the template matrix are created fresh. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>x is (weakly) preferred to y if obj(x) - obj(y) lies in cone. If reference uses only core objectives, orderConeIdx can be omitted and defaults to the corresponding orthant cone</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constantMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective;        zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ComplexConstraints">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="complexCon" type="ComplexCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfComplexCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexCon">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="symmetry" type="SymmetryType" default="none">
			<xs:annotation>
				<xs:documentation>e.g., if symmetry = "upper", only variables in the upper triangle (including diagonal) are generated and passed to the solver interface.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="templateMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>matrix constraint has a nonzero entry wherever the template matrix does also. If templateMatrixIdx missing: Completely dense matrix.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conReferenceMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core constraints instead of creation of new ones. 
Note: only where template matrix indicates a nonzero.
If missing, all constraints indicated  by the use of the template matrix are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains mtx expr - lbMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant matrix; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx -  mtx expr; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="ComplexExpressions">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="ComplexExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ComplexExpression">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLCNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing complex objectives (if negative) or complex constraints (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--TensorProgramming: experiment-->
	<xs:complexType name="TensorProgramming">
		<xs:annotation>
			<xs:documentation>experiment--</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="tensorVariables" type="TensorVariables" minOccurs="0"/>
			<xs:element name="tensorObjectives" type="TensorObjectives" minOccurs="0"/>
			<xs:element name="tensorConstraints" type="TensorConstraints" minOccurs="0"/>
			<xs:element name="tensorExpressions" type="TensorExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>For tensor-valued expressions only - scalar-valued expressions should be set up as nonlinearExpressions</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="TensorVariables">
		<xs:sequence>
			<xs:element name="tensorVar" type="TensorVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfTensorVar after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorVar">
		<xs:sequence>
			<xs:element name="dimensions" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of dimensions must equal the tensor rank</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="descriptor" type="TensorVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptiors
can be used to set up special tensors with properties not otherwise available</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name"/>
		<xs:attribute name="rank" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="templateTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>tensor variable has a nonzero entry wherever the template tensor does also. If templateTensorIdx missing: Completely dense tensor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varReferenceTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core variables instead of creation of new ones. 
Note: only where template tensor indicates a nonzero.
If missing, all variables indicated  by the use of the template tensor are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="varType" type="GeneralEnumerationVarType" use="optional" default="C">
			<xs:annotation>
				<xs:documentation>same type for every newly created variable; default is 'C'; variables inherited from the core keep the type and bounds declared in the core.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains varMtx - lbMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx - varMtx; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
	</xs:complexType>
	<xs:complexType name="TensorVarOrConDescriptor" mixed="true">
		<xs:attribute name="name" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:minLength value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="description" type="xs:string" use="optional"/>
		<xs:attribute name="value" type="xs:string" use="optional"/>
		<xs:attribute name="type" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="TensorObjectives">
		<xs:sequence>
			<xs:element name="tensorObj" type="TensorObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfTensorObj after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorObj">
		<xs:sequence>
			<xs:element name="dimensions" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of dimensions must equal the tensor rank</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name"/>
		<xs:attribute name="rank" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="templateTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>tensor objective has a nonzero entry wherever the template rtensor does also. If templateTensorIdx missing: Completely dense tensor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="objReferenceTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core objectives instead of creation of new ones. 
Note: only where template tensor indicates a nonzero.
If missing, all objectives indicated  by the use of the template tensor are created fresh. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>x is (weakly) preferred to y if obj(x) - obj(y) lies in cone. If reference uses only core objectives, orderConeIdx can be omitted and defaults to the corresponding orthant cone</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="constantTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>added to objective;        zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="TensorConstraints">
		<xs:sequence>
			<xs:element name="tensorCon" type="TensorCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must match numberOfTensorCon after "mult" has been considered</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTensorCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorCon">
		<xs:sequence>
			<xs:element name="dimensions" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of dimensions must equal the tensor rank</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="descriptor" type="TensorVarOrConDescriptor" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfDescriptiors
can be used, e.g., to set up Toeplitz matrices</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name"/>
		<xs:attribute name="rank" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="templateTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>tensor constraint has a nonzero entry wherever the template tensor does also. If templateTensorIdx missing: Completely dense tensor.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conReferenceTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>controls reuse of core constraints instead of creation of new ones. 
Note: only where template tensor indicates a nonzero.
If missing, all constraints indicated  by the use of the template tensor are created fresh.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains tensor expr - lbTensor; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubTensorIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>must be constant tensor; zero if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>contains ubMtx -  mtx expr; assumed all R^n if missing</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional" default="1"/>
		<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" default="0"/>
	</xs:complexType>
	<xs:complexType name="TensorExpressions">
		<xs:sequence>
			<xs:element name="expr" type="TensorExpression" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number must agree with numberOfExpr</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TensorExpression">
		<xs:annotation>
			<xs:documentation>since version 2.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLMNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>refers to existing tensor objective (if negative) or tensor constraint (if nonnegative)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="general">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="general"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SpecialOrderedSets">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of child elements must match numberOfSOS
				</xs:documentation>
			</xs:annotation>
			<xs:element name="sos" type="SOS" minOccurs="0" maxOccurs="unbounded">
				<!--
SOS type 1 means "at most, or usually, exactly one of these variables can be nonzero (usually, in fact, 1)". This is used most commonly to model disjunctions. Type 2 means "at most two of these variables can be nonzero, and the two variables must be consecutive". This is used to model piecewise linear (typically nonconvex) functions in one variable. Tomlin used SOS to model nonconvex functions in two variables, using a triangulation of the domain. This idea can also be used for approximations in higher dimensions. In addition there may be the requirement that all the nonzero variables in an SOS must add up to 1. If present, this is called the convexity constraint. (It is the user's responsibility to add the convexity constraint to the problem.) The attribute "convexityRowIdx" can be used to identify the
convexity row to the solver, which might speed up the execution time.
-->
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSOS" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SOS">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="NonNegativeIntVector" minOccurs="0"/>
			<xs:element name="adjacentVariableSets" type="SOSAdjacentVariableSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Only required if type >= 3.      All nonzero variables must belong to the same adjacency set. Adjacency variable sets must be subsets of the SOS variable set.
If type = 2 adjacent variables are by default consecutive entries in the variables list.</xs:documentation>
				</xs:annotation>
				<!--
In an SOS2, adjacency usually means that nonzero variables must be consecutive within the set. They are used to model piecewise linear functions of one variable, and what is adjacent should be reasonably clear. In an SOS3 the adjacent points are the vertices of a triangle (a two-dimensional simplex), and one cannot infer the adjacency from the order of the variables in the SOS. One also cannot infer  the size of the triangulation. That's why one needs to specify adjacency lists here. Since it is possible to omit such lists for SOS2 (and certainly for SOS1), it makes sense to allow for 0 adjacencySets. (And each triangle forms its own set, hence the plural.)-->
			</xs:element>
		</xs:sequence>
		<xs:attribute name="type" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation>"type = k" means at most k of the variables in this SOS can be nonzero, and the nonzeros must be "adjacent"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="convexityRowIdx" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>if present must refer to a previously defined constraint of the form 
x_i1 + x_i2 + ... = 1. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SOSAdjacentVariableSets">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="set" type="NonNegativeIntVector" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Number of sets must match numberOfSets</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSets" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!--Cones: draft -->
	<xs:complexType name="Cones">
		<xs:annotation>
			<xs:documentation>since version 2.0 </xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of various cone child elements must match numberOfCones</xs:documentation>
			</xs:annotation>
			<xs:group ref="ConeGroup"/>
		</xs:sequence>
		<xs:attribute name="numberOfCones" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:group name="ConeGroup">
		<xs:choice>
			<xs:element name="nonnegativeCone" type="NonnegativeCone"/>
			<xs:element name="nonpositiveCone" type="NonpositiveCone"/>
			<xs:element name="generalOrthantCone" type="OrthantCone"/>
			<xs:element name="polyhedralCone" type="PolyhedralCone"/>
			<xs:element name="quadraticCone" type="QuadraticCone"/>
			<xs:element name="rotatedQuadraticCone" type="RotatedQuadraticCone"/>
			<xs:element name="normedCone" type="NormedCone"/>
			<xs:element name="semidefiniteCone" type="SemidefiniteCone"/>
			<xs:element name="copositiveMatricesCone" type="CopositiveMatricesCone"/>
			<xs:element name="completelyPositiveMatricesCone" type="CompletelyPositiveMatricesCone"/>
			<xs:element name="hyperbolicityCone" type="HyperbolicityCone"/>
			<xs:element name="sumOfSquaresPolynomialsCone" type="SumOfSquaresPolynomialsCone"/>
			<xs:element name="nonnegativePolynomialsCone" type="ConeWithNonnegativePolynomials">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="momentCone" type="ConeWithNonnegativePolynomials">
				<xs:annotation>
					<xs:documentation>experiment. The cone of moments is the _dual_ of a corresponding cone of nonnegative polynomials</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="productCone" type="ProductCone"/>
			<xs:element name="intersectionCone" type="IntersectionCone"/>
			<xs:element name="dualCone" type="DualCone"/>
			<xs:element name="polarCone" type="PolarCone"/>
			<xs:element name="customCone" type="CustomCone"/>
		</xs:choice>
	</xs:group>
	<xs:complexType name="GenericCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="otherIndexes" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>use for tensors of rank >= 3. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfColumns" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="NonnegativeCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NonpositiveCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OrthantCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="direction" type="OrthantConeDirection" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>There must be (numberOfRows* NumberOfColumns) directions (after accounting for 'mult'). Row index changes fastest, then column index, then other indexes.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OrthantConeDirection">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="nonnegative"/>
					<xs:enumeration value="nonpositive"/>
					<xs:enumeration value="free"/>
					<xs:enumeration value="zero"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="PolyhedralCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="direction" type="PolyhedralConeDirection" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>If present, the number of directions must correspond to the dimensions of the product Ax (after accounting for 'mult'). Row index changes fastest, then column index, then other indexes.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="referenceMatrixIdx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="coneDirection" use="optional">
					<xs:annotation>
						<xs:documentation>'positive': Ax \ge 0; 'negativ'e: Ax \le 0; 
'mixed': specified by 'direction' element</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="positive"/>
							<xs:enumeration value="negative"/>
							<xs:enumeration value="mixed"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PolyhedralConeDirection">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="nonnegative"/>
					<xs:enumeration value="nonpositive"/>
					<xs:enumeration value="free"/>
					<xs:enumeration value="zero"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="mult" type="xs:positiveInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="QuadraticCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="axisDirection" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>This is an index of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RotatedQuadraticCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="firstAxisDirection" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>Each is an index of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="secondAxisDirection" type="xs:nonNegativeInteger" use="optional" default="1"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NormedCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="axisDirectionIndex" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>index is of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="pNorm" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:minInclusive value="1.0" fixed="false"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RotatedNormedCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="distortionMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
				<xs:attribute name="normScaleFactor" type="PositiveDouble" use="optional" default="1.0"/>
				<xs:attribute name="firstAxisDirection" type="xs:nonNegativeInteger" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>Each is an index of the form i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="secondAxisDirection" type="xs:nonNegativeInteger" use="optional" default="1"/>
				<xs:attribute name="pNorm" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:minInclusive value="1.0" fixed="false"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SemidefiniteCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="semidefiniteness" use="optional" default="positive">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="positive"/>
							<xs:enumeration value="negative"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="symmetry" type="xs:boolean" default="true"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CopositiveMatricesCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="symmetry" type="xs:boolean" default="true"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompletelyPositiveMatricesCone">
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="symmetry" type="xs:boolean" default="true"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="HyperbolicityCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:choice>
						<xs:element name="singleVariablePolynomial" type="SingleVariablePolynomial"/>
						<xs:element name="multiVariablePolynomial" type="MultiVariablePolynomial"/>
					</xs:choice>
					<xs:element name="direction" type="SparseVector">
						<xs:annotation>
							<xs:documentation>dimension of direction vector must equal the number of variables in the polynomial</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SumOfSquaresPolynomialsCone">
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="maxDegree" default="INF">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:pattern value="[0-9]+|INF"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConeWithNonnegativePolynomials">
		<xs:annotation>
			<xs:documentation>experiment. Used for both a cone of nonnegative polynomials and its dual, a moment cone</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="upperBounds" type="SparseVector" minOccurs="0">
						<xs:annotation>
							<xs:documentation>upper bounds on domain of polynomial. Default is +INF. Indexes are "flattened": i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="lowerBounds" type="SparseVector" minOccurs="0">
						<xs:annotation>
							<xs:documentation>lower bounds on domain of polynomial. Default is -INF. Indexes are "flattened": i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="maxDegree" default="INF">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:pattern value="[0-9]+|INF"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--	
	<xs:complexType name="MomentsCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="upperBounds" type="SparseVector" minOccurs="0">
						<xs:annotation>
							<xs:documentation>upper bounds on domain of polynomial. Default is +INF. Indexes are "flattened": i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="lowerBounds" type="SparseVector" minOccurs="0">
						<xs:annotation>
							<xs:documentation>lower bounds on domain of polynomial. Default is -INF. Indexes are "flattened": i0*n1*n2*... + i1*n2*n3... + ... + i_r, with zero-based indices i0, i1, ..., i_r</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="maxDegree" default="INF">
					<xs:simpleType>
						<xs:restriction base="xs:double">
							<xs:pattern value="[0-9]+|INF"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
-->
	<xs:complexType name="ProductCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="factors" type="NonNegativeIntVector">
						<xs:annotation>
							<xs:documentation>each factor gives the index of a previously defined cone</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ProductConeFactor">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:attribute name="coneId" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="IntersectionCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="components" type="NonNegativeIntVector">
						<xs:annotation>
							<xs:documentation>each component gives the index of a previously defined cone</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IntersectionConeComponent">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:attribute name="coneId" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="DualCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="referenceConeIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PolarCone">
		<xs:annotation>
			<xs:documentation>draft </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:attribute name="referenceConeIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CustomCone">
		<xs:complexContent>
			<xs:extension base="GenericCone">
				<xs:sequence>
					<xs:element name="descriptor" type="Descriptor" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="numberOfDescriptors" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RealTimeData">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="defaultURI" type="xs:anyURI" default="." minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="defaultRefreshPoint" type="RefreshPointEnum" default="onOptimizationStart" minOccurs="0"/>
			<xs:element name="realTimeDataSource" type="RealTimeDataSource" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfDataSources</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDataSources" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeDataSource">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:annotation>
					<xs:documentation>if both uri and uriAlias missing, use defaultURI</xs:documentation>
				</xs:annotation>
				<xs:element name="uri" type="xs:anyURI"/>
				<xs:element name="uriAlias" type="xs:string"/>
			</xs:choice>
			<xs:element name="dataPoint" type="RealTimeDataPoint" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="refreshPoint" type="RefreshPointEnum">
			<xs:annotation>
				<xs:documentation>if missing, use value of defaultRefreshPoint</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfDataPoints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeDataPoint">
		<xs:annotation>
			<xs:documentation>number must agree with numberOfDataPoints</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="sourceXPath" type="xs:string"/>
			<xs:element name="targetComponent" type="RealTimeUpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTargetComponents</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTargetComponents" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DOMNode">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RealTimeUpdateableProblemComponent">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent_test"/>
		</xs:sequence>
		<xs:attribute name="constant" type="xs:double" default="0.0"/>
		<xs:attribute name="coef" type="xs:double" default="1.0"/>
	</xs:complexType>
	<xs:complexType name="RealTimeDataElement">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="value" type="xs:ID" use="required"/>
				<xs:attribute name="type" use="optional" default="string">
					<xs:annotation>
						<xs:documentation>default is "real"</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="string"/>
							<xs:enumeration value="link"/>
							<xs:enumeration value="real"/>
							<xs:enumeration value="integer"/>
							<xs:enumeration value="xPath"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="new_Simulations">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="defaultURI" type="xs:anyURI" default="." minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="defaultRefreshPoint" default="onInputChange" minOccurs="0">
				<xs:simpleType>
					<xs:restriction base="RefreshPointEnum"/>
				</xs:simpleType>
			</xs:element>
			<xs:element name="new_simulation" type="new_Simulation" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfSimulations</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfSimulations" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="new_Simulation">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:annotation>
					<xs:documentation>if both uri and uriAlias missing, use defaultURI</xs:documentation>
				</xs:annotation>
				<xs:element name="uri" type="xs:anyURI" minOccurs="0"/>
				<xs:element name="uriAlias" type="xs:nonNegativeInteger" minOccurs="0"/>
			</xs:choice>
			<xs:element name="input" type="new_SimulationInputOrOutput" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="output" type="new_SimulationInputOrOutput" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="numberOfInputs" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfOutputs" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="refreshPoint"/>
	</xs:complexType>
	<xs:complexType name="new_SimulationInputOrOutput">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="el" type="new_SimulationElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization.  number must agree with numberOfEl</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="new_SimulationElement">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="value" type="xs:ID" use="required"/>
				<xs:attribute name="type" use="optional" default="string">
					<xs:annotation>
						<xs:documentation>default is "real"</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="string"/>
							<xs:enumeration value="link"/>
							<xs:enumeration value="real"/>
							<xs:enumeration value="integer"/>
							<xs:enumeration value="xPath"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="UpdateableData">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="defaultURI" type="xs:anyURI" default="." minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="defaultRefreshPoint" type="RefreshPointEnum" default="onOptimizationStart" minOccurs="0"/>
			<xs:element name="updateableDataItem" type="UpdateableDataItem" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfDataItems</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDataItems" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableDataItem">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:annotation>
					<xs:documentation>if both uri and uriAlias missing, use defaultURI</xs:documentation>
				</xs:annotation>
				<xs:element name="uri" type="xs:anyURI" minOccurs="0"/>
				<xs:element name="uriAlias" type="xs:nonNegativeInteger" minOccurs="0"/>
			</xs:choice>
			<xs:element name="input" type="UpdateableDataItemInputOrOutput" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="output" type="UpdateableDataItemInputOrOutput" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="numberOfInputs" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfOutputs" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="refreshPoint"/>
	</xs:complexType>
	<xs:complexType name="UpdateableDataItemInputOrOutput">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="el" type="UpdateableDataElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfElements" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableDataElement">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="value" type="xs:ID" use="required"/>
				<xs:attribute name="type" use="optional" default="string">
					<xs:annotation>
						<xs:documentation>default is "real"</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="string"/>
							<xs:enumeration value="link"/>
							<xs:enumeration value="real"/>
							<xs:enumeration value="integer"/>
							<xs:enumeration value="xPath"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--Modifications: draft -->
	<xs:complexType name="InstanceModifications">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModifyingOperations">
				<xs:choice minOccurs="0">
					<xs:element name="baseFile" type="ModificationBaseFile" default="this">
						<xs:annotation>
							<xs:documentation>reference to an OSiL file containing the base for the current modifications</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="baseID" type="xs:string">
						<xs:annotation>
							<xs:documentation>reference to a previous modification available in memory</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
				<xs:attribute name="refID" type="xs:string">
					<xs:annotation>
						<xs:documentation>defines a reference for subsequent reuse of this modification.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModificationBaseFile">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="uri" type="xs:string" use="optional" default="."/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ModificationUpdates">
		<xs:sequence>
			<xs:element name="subst" type="ModificationsUpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfSubst" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationsUpdateableProblemComponent">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent_test"/>
		</xs:sequence>
		<xs:attribute name="value" type="xs:double" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeletions">
		<xs:sequence>
			<xs:element name="variables" type="ModificationDeleteVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="ModificationDeleteObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="ModificationDeleteConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="ModificationDeleteLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="ModificationDeleteQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationDeleteNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="ModificationDeleteMatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="ModificationDeleteMatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="ModificationDeleteMatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="ModificationDeleteMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteVariables">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="var" type="ModificationDeleteVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a variable, its cost and constraint coefficients, and all quadratic terms and nonlinear expressions in which the variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteVar">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteObjectives">
		<xs:sequence>
			<xs:element name="obj" type="ModificationDeleteObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteObj">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="colIdx">
			<xs:annotation>
				<xs:documentation>If present, delete only the objective coefficient in this column</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteConstraints">
		<xs:sequence>
			<xs:element name="con" type="ModificationDeleteCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteCon">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteLinearConstraintCoefficients">
		<xs:sequence>
			<xs:element name="el" type="ModificationDeleteLinearConstraintEl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteLinearConstraintEl">
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteQuadraticCoefficients">
		<xs:sequence>
			<xs:element name="qTerm" type="ModificationDeleteQTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteQTerm">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxOne" use="required"/>
		<xs:attribute name="idxTwo" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteNonlinearExpressions">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="nl" type="ModificationDeleteNl"/>
		</xs:sequence>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteNl">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixVariables">
		<xs:sequence>
			<xs:element name="matrixVar" type="ModificationDeleteMatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a matrix variable and all terms in all nonlinear and matrix expressions in which the matrix variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixVar">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixObjectives">
		<xs:sequence>
			<xs:element name="matrixObj" type="ModificationDeleteMatrixObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixObj">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixConstraints">
		<xs:sequence>
			<xs:element name="matrixCon" type="ModificationDeleteMatrixCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixCon">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixExpressions">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="expr" type="ModificationDeleteMatrixExpr"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationDeleteMatrixExpr">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAdditions">
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectiveCoefficients" type="ModificationAddObjectiveCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add objective coeffficients into existing objectves</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add new objectives and their coefficientss</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="ModificationAddLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationAddNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="MatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="MatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="MatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="MatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="ComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="ComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="ComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexExpressions" type="ComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ModificationAddVariables">
		<xs:sequence>
			<xs:element name="var" type="Variable" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVariables" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddObjectiveCoefficients">
		<xs:sequence>
			<xs:element name="obj" type="ModificationAddObjective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddObjective">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number of coef child elements must match numberOfObjCoef</xs:documentation>
			</xs:annotation>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>If idx is repeated, the objective terms/coefficients are added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>must refer to a previously existing objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddObjCoef">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ModificationAddObjectives">
		<xs:sequence>
			<xs:element name="obj" type="Objective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddConstraints">
		<xs:sequence>
			<xs:element name="con" type="Constraint" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/> -->
	</xs:complexType>
	<xs:complexType name="ModificationAddLinearConstraintCoefficients">
		<xs:sequence>
			<xs:element name="el" type="ModificationAddLinearConstraintCoefficientsEl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddLinearConstraintCoefficientsEl">
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="value" type="xs:double" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddQuadraticCoefficients">
		<xs:sequence>
			<xs:element name="qTerm" type="QuadraticTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQuadraticTerms" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddNonlinearExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="nl" type="Nl"/>
		</xs:choice>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddNl">
		<xs:choice maxOccurs="unbounded">
			<xs:element ref="OSnLNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddMatrixVariables">
		<xs:sequence>
			<xs:element name="matrixVar" type="MatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddMatrixObjectives">
		<xs:sequence>
			<xs:element name="matrixObj" type="MatrixObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddMatrixConstraints">
		<xs:sequence>
			<xs:element name="matrixCon" type="MatrixCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddMatrixExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="MatrixExpression"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddMatrixExpr">
		<xs:choice maxOccurs="unbounded">
			<xs:element ref="OSnLMNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddComplexVariables">
		<xs:sequence>
			<xs:element name="complexVar" type="ComplexVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationAddComplexObjectives">
		<xs:sequence>
			<xs:element name="complexObj" type="ComplexObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddComplexConstraints">
		<xs:sequence>
			<xs:element name="con" type="ComplexCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddComplexExpressions">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="ModificationAddComplexExpr"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ModificationAddComplexExpr">
		<xs:choice maxOccurs="unbounded">
			<xs:element ref="OSnLCNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<!--	
	<xs:simpleType name="ModificationType">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="update"/>
			<xs:enumeration value="add"/>
			<xs:enumeration value="insert"/>
			<xs:enumeration value="delete"/>
		</xs:restriction>
	</xs:simpleType>
-->
	<xs:complexType name="ModifyingOperations">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="substitutions" type="ModificationUpdates" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="deletions" type="ModificationDeletions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additions" type="ModificationAdditions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--DisjunctiveInformation: proposal-->
	<xs:complexType name="old_DisjunctiveInformation">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the disjunctiveSet child elements must agree with numberOfDisjunctiveSets</xs:documentation>
			</xs:annotation>
			<xs:element name="disjunctiveSet" type="old_DisjunctiveSet" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctiveSets" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="lbInclusive" type="xs:boolean" use="optional" default="true"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="ubInclusive" type="xs:boolean" use="optional" default="true"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the var child elements must agree with numberOfVariables</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="old_DisjunctionVar" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfVariables" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the coef child elements must agree with numberOfObjCoef</xs:documentation>
			</xs:annotation>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="weight" type="xs:double" use="optional" default="1.0"/>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="optional" default="0"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the obj child elements must agree with numberOfObjectives</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="old_DisjunctionObj" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
		<xs:attribute name="lbInclusive" type="xs:boolean" use="optional" default="true"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="ubInclusive" type="xs:boolean" use="optional" default="true"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="old_DisjunctionCon" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionObjectiveCoefficientElement">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="rowIdx" type="xs:negativeInteger" use="required"/>
				<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionObjectiveCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the el child elements must agree with numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="el" type="old_DisjunctionObjectiveCoefficientElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if this location cooincdes with core information, the data get added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionLinearConstraintCoefficientElement">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionLinearConstraintCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the el child elements must agree with numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="el" type="old_DisjunctionLinearConstraintCoefficientElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if this location cooincdes with core information, the data get added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionQuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms</xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="QuadraticTerm" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if this location cooincdes with core information, the data get added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfQTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionQuadraticTerm">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="coef" type="xs:double" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionNonlinearExpressions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="nl" type="Nl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_DisjunctionNl">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element ref="OSnLNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_Disjunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="variables" type="old_DisjunctionVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="old_DisjunctionObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="old_DisjunctionConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="old_DisjunctionLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="old_DisjunctionQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="cones" type="Cones" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uncertaintySets" type="UncertaintySets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="timeDomain" type="TimeDomain" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticData" type="StochasticData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="softConstraints" type="SoftConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!--			
			<xs:element name="realTimeData" type="old_RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
		</xs:sequence>
		<xs:attribute name="base" use="optional" default="coreProgram">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="none"/>
					<xs:enumeration value="coreProgram"/>
					<xs:enumeration value="firstDisjunction"/>
					<xs:enumeration value="lastDisjunction"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="old_DisjunctiveSet">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the disjunction child elements must agree with numberOfDisjunctions</xs:documentation>
			</xs:annotation>
			<xs:element name="disjunction" type="old_Disjunction" minOccurs="2" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!-- a new proposal for disjunctions -->
	<xs:complexType name="Disjunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<!--			
			<xs:element name="realTimeData" type="old_RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:sequence>
				<xs:annotation>
					<xs:documentation>These elements work at the model level (to include or exclude entire variables or constraints)</xs:documentation>
				</xs:annotation>
				<xs:element name="variables" type="DisjunctionVariables" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="objectives" type="DisjunctionObjectives" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="constraints" type="DisjunctionConstraints" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="specialOrderedSets" type="DisjunctionSpecialOrderedSets" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="matrixVariables" type="DisjunctionMatrixVariables" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="matrixObjectives" type="DisjunctionMatrixObjectives" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="matrixConstraints" type="DisjunctionMatrixConstraints" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:annotation>
					<xs:documentation>These elements affect the term level only (to include or exclude portions of a constraint or objective)</xs:documentation>
				</xs:annotation>
				<xs:element name="objectiveCoefficients" type="DisjunctionObjectiveCoefficients" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="linearConstraintCoefficients" type="DisjunctionLinearConstraintCoefficients" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="quadraticCoefficients" type="DisjunctionQuadraticCoefficients" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="nonlinearExpressions" type="DisjunctionNonlinearExpressions" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="matrixExpressions" type="DisjunctionMatrixExpressions" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="complexValuedExpressions" type="DisjunctionComplexValuedExpressions" minOccurs="0">
					<xs:annotation>
						<xs:documentation>proposal</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
		</xs:sequence>
		<xs:attribute name="conditioningVariableIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>disjunction is enforced only if logical conditioning variable is TRUE</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conditioningConstraintIdx">
			<xs:annotation>
				<xs:documentation>disjunction is enforced only if logical conditioning constraint is TRUE</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DisjunctionObjectiveCoefficientElement">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="rowIdx" type="xs:negativeInteger" use="required"/>
				<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="DisjunctionObjectiveCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the el child elements must agree with numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="el" type="DisjunctionObjectiveCoefficientElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if this location coincides with core information, the data get added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionLinearConstraintCoefficientElement">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="DisjunctionLinearConstraintCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the el child elements must agree with numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="el" type="DisjunctionLinearConstraintCoefficientElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if this location coincides with core information, the data get added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionQuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms</xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="QuadraticTerm" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if this location cooincdes with core information, the data get added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfQTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionQuadraticTerm">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="coef" type="xs:double" use="optional" default="1"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionNonlinearExpressions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="nl" type="DisjunctionNl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionNl">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:annotation>
				<xs:documentation>refers to an idx in the list of nonlinear expressions</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixExpressions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="MatrixExpression" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionComplexValuedExpressions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="expr" type="ComplexValuedExpression" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctiveSet">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of alternatives must agree with numberOfAlternatives</xs:documentation>
			</xs:annotation>
			<!-- dead code	
			<xs:element name="disjunction" type="Disjunction" minOccurs="2" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>different disjunctions are connected by exclusive OR</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="disjunctiveTerm" type="DisjunctiveModifications" minOccurs="2" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>different disjunctive terms are connected by logical OR</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctiveTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="constant" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="weight" type="xs:double" use="optional" default="1.0"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionSOS">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="constantMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="orderConeIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lbMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="lbConeIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="ubMatrixIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="ubConeIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the var child elements must agree with numberOfVariables</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="DisjunctionVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if lb or ub are mentioned, they replace core information</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the obj child elements must agree with numberOfObjectives</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="DisjunctionObj" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if constant or weight is mentioned, it replaces information in the core</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="DisjunctionCon" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>if lb or up are mentioned, they replace core information</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionSpecialOrderedSets">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="sos" type="DisjunctionSOS" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfSOS" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="matrixVar" type="DisjunctionMatrixVar" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="matrixObj" type="DisjunctionMatrixObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctionMatrixConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="matrixCon" type="DisjunctionMatrixCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctiveInformation">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of disjunctions must agree with numberOfDisjunctions</xs:documentation>
			</xs:annotation>
			<xs:element name="conditioningVariables" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>to identify logical core variables that describe conditions under which one of the disjunctions holds</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="conditioningConstraints" type="NonNegativeIntVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>to identify core contraints that describe additional restrictions on the logical conditioningVariables</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunction" type="DisjunctiveSet" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>different disjunctive sets are connected by logical AND</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="DisjunctiveModifications">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModifyingOperations">
				<xs:attribute name="conditioningVariableIdx" type="xs:nonNegativeInteger">
					<xs:annotation>
						<xs:documentation>disjunction is enforced only if logical conditioning variable is TRUE</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="conditioningConstraintIdx">
					<xs:annotation>
						<xs:documentation>disjunction is enforced only if logical conditioning constraint is TRUE</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- end of new disjunctions -->
	<!--Parameters: proposal-->
	<xs:complexType name="ParametricData">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="LinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="cones" type="Cones" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctiveInformation" type="ParamDisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="old_RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Parameters">
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the param child elements must agree with numberOfParameters</xs:documentation>
			</xs:annotation>
			<xs:element name="param" type="Param_test" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfParameters" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Param">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="UpdateableProblemComponent">
				<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
				<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
				<xs:attribute name="type" type="GeneralEnumerationVarType" use="optional" default="C"/>
				<xs:attribute name="nominalValue" type="xs:double" use="optional" default="0.0"/>
				<xs:attribute name="incr" type="xs:double">
					<xs:annotation>
						<xs:documentation>default is (ub-lb)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="id" type="xs:ID"/>
				<xs:attribute name="description" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ParamSetRowInCore">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="modifier" use="optional" default="all">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="all"/>
					<xs:enumeration value="any"/>
					<xs:enumeration value="avg"/>
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ParamSetRowsInCore">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="row" type="ParamSetRowInCore" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ParamDisjunctionParam">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="lbInclusive" type="xs:boolean" use="optional" default="true"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="ubInclusive" type="xs:boolean" use="optional" default="true"/>
	</xs:complexType>
	<xs:complexType name="ParamDisjunctionParameters">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="param" type="ParamDisjunctionParam" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfParameters" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ParamDisjunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="parameters" type="ParamDisjunctionParameters" minOccurs="0"/>
			<xs:element name="constraints" type="DisjunctionConstraints" minOccurs="0"/>
			<xs:element name="linearConstraintCoefficients" type="DisjunctionLinearConstraintCoefficients" minOccurs="0"/>
			<xs:element name="quadraticCoefficients" type="DisjunctionQuadraticCoefficients" minOccurs="0"/>
			<xs:element name="nonlinearExpressions" type="DisjunctionNonlinearExpressions" minOccurs="0"/>
			<xs:element name="realTimeData" type="old_RealTimeData" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="base" use="optional" default="coreProgram">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="none"/>
					<xs:enumeration value="coreProgram"/>
					<xs:enumeration value="firstDisjunction"/>
					<xs:enumeration value="lastDisjunction"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ParamDisjunctiveSet">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="disjunction" type="ParamDisjunction" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunction" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ParamDisjunctiveInformation">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="disjunctiveSet" type="ParamDisjunctiveSet" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfDisjunctiveSets" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Distributions">
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the dist child elements must agree with numberOfDist</xs:documentation>
			</xs:annotation>
			<xs:element name="dist" type="StochasticDistribution" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDist" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="Distribution">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element name="mean" type="StochasticNumberVar" minOccurs="0"/>
			<xs:element name="variance" type="StochasticNumberObj" minOccurs="0"/>
			<xs:element name="correlation" type="StochasticNumberCon" minOccurs="0"/>
			<xs:element name="covariance" type="StochasticNumberLinearConstraintCoefficientsEl" minOccurs="0"/>
			<xs:element name="param" type="StochasticNumberQuadraticCoefficientsQTerm" minOccurs="0"/>
		</xs:choice>
		<xs:attribute name="type" use="required"/>
		<xs:attribute name="dimension" type="xs:nonNegativeInteger" use="optional" default="1"/>
		<xs:attribute name="numberOfParam" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="description" type="xs:string"/>
		<!--type="DistributionType"-->
	</xs:complexType>
	<xs:complexType name="UncertaintySets">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="uncertaintySet" type="UncertaintySet" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfUncertaintySets" use="required"/>
	</xs:complexType>
	<xs:complexType name="UncertaintySet">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="LinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="QuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="cones" type="Cones" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctiveInformation" type="ParamDisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="old_RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentVariable">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="type"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentObjective">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="weight"/>
					<xs:enumeration value="coef"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="varIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>required if attr="coef"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentConstraint">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentLinearConstraintCoefficient">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentQuadraticCoefficient">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:int" use="required"/>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNlNode">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:IDREF" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentNlCNode">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:string" use="required"/>
		<xs:attribute name="part" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="real"/>
					<xs:enumeration value="imaginary"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponentMatrixElement">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="matrixIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="UpdateableProblemComponent">
		<xs:choice>
			<!-- minOccurs="0" maxOccurs="unbounded">  -->
			<xs:element name="var" type="UpdateableProblemComponentVariable">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="obj" type="UpdateableProblemComponentObjective">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the objective</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="con" type="UpdateableProblemComponentConstraint">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficient" type="UpdateableProblemComponentLinearConstraintCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the constraint matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="qCoef" type="UpdateableProblemComponentQuadraticCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the quadratic expressions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OSnLNode" type="UpdateableProblemComponentNlNode">
				<xs:annotation>
					<xs:documentation>draft - refer to any OSnLNode in any nonlinear expression, including matrix constructs</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixElement" type="UpdateableProblemComponentMatrixElement">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:group name="UpdateableProblemComponent_test">
		<xs:choice>
			<xs:element name="var" type="UpdateableProblemComponentVariable">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="obj" type="UpdateableProblemComponentObjective">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the objective</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="con" type="UpdateableProblemComponentConstraint">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficient" type="UpdateableProblemComponentLinearConstraintCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the constraint matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="qCoef" type="UpdateableProblemComponentQuadraticCoefficient">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the quadratic expressions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OSnLNode" type="UpdateableProblemComponentNlNode">
				<xs:annotation>
					<xs:documentation>draft - refer to any OSnLNode in any nonlinear expression, including matrix constructs</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixElement" type="UpdateableProblemComponentMatrixElement">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:complexType name="Param_test">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent_test"/>
			<xs:element name="genericParameter" type="GenericParameter"/>
		</xs:choice>
		<xs:attribute name="lb" type="xs:double" use="optional" default="-INF"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="type" type="GeneralEnumerationVarType" use="optional" default="C"/>
		<xs:attribute name="nominalValue" type="xs:double" use="optional" default="0.0"/>
		<xs:attribute name="incr" type="xs:double">
			<xs:annotation>
				<xs:documentation>default is (ub-lb)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="id" type="xs:ID"/>
		<xs:attribute name="description" type="xs:string" use="optional"/>
	</xs:complexType>
	<xs:complexType name="GenericParameter">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="name" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ModificationUpdates_test">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="subst" type="ModificationsUpdateableProblemComponent_test"/>
		</xs:sequence>
		<xs:attribute name="numberOfSubst" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="ModificationsUpdateableProblemComponent_test">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent_test"/>
		</xs:sequence>
		<xs:attribute name="value" type="xs:double" use="required"/>
	</xs:complexType>
	<!--RealTimeData: recommendation-->
	<xs:complexType name="old_RealTimeData">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="defaultURI" type="xs:anyURI" default="." minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="parameters" type="old_RealTimeDataParameters" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="variables" type="old_RealTimeDataVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="old_RealTimeDataObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="old_RealTimeDataConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="old_RealTimeDataLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="old_RealTimeDataQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="old_RealTimeDataNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RealTimeDataURI">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:anyURI">
				<xs:attribute name="alias" type="xs:string" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="RealTimeDataURIAliases">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the url child elements must agree with numberOfURIAliases</xs:documentation>
			</xs:annotation>
			<xs:element name="uri" type="RealTimeDataURI" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfURIAliases" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataParam">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lb"/>
							<xs:enumeration value="ub"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataParameters">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the param child elements must agree with numberOfParameters</xs:documentation>
			</xs:annotation>
			<xs:element name="param" type="old_RealTimeDataParam" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfParameters" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataVar">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lb"/>
							<xs:enumeration value="ub"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataVariables">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the var child elements must agree with numberOfVariables</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="old_RealTimeDataVar" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfVariables" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataCon">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lb"/>
							<xs:enumeration value="ub"/>
							<xs:enumeration value="constant"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataConstraints">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the con child elements must agree with numberOfConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="old_RealTimeDataCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataObj">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="constant"/>
							<xs:enumeration value="weight"/>
							<xs:enumeration value="coef"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="varIdx" type="xs:nonNegativeInteger" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataObjectives">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the obj child elements must agree with numberOfObjectives</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="old_RealTimeDataObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataLinearConstraintCoefficientElement">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataLinearConstraintCoefficients">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the el child elements must agree with numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="el" type="old_RealTimeDataLinearConstraintCoefficientElement" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataQuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms</xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="old_RealTimeDataQuadraticTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQuadraticTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataQuadraticTerm">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataNonlinearExpressionNumber">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="id" type="xs:IDREF" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataNonlinearExpressionString">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RealTimeAccess">
				<xs:attribute name="id" type="xs:IDREF" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="old_RealTimeDataNonlinearExpressions">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of the number and string child elements must agree with numberOfNonlinearNumbersAndStrings</xs:documentation>
			</xs:annotation>
			<xs:element name="number" type="old_RealTimeDataNonlinearExpressionNumber"/>
			<xs:element name="string" type="old_RealTimeDataNonlinearExpressionString"/>
		</xs:choice>
		<xs:attribute name="numberOfNonlinearExpressionNumbersAndStrings" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeAccessXPath">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:attribute name="uri" type="xs:anyURI" use="optional" default="."/>
		<xs:attribute name="uriAlias" type="xs:string" use="optional"/>
		<xs:attribute name="path" type="xs:string" use="required"/>
	</xs:complexType>
	<xs:complexType name="RealTimeAccess">
		<xs:annotation>
			<xs:documentation>recommendation</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="xPath" type="RealTimeAccessXPath"/>
		</xs:sequence>
	</xs:complexType>
	<!--AmbiguityResolution: experiment-->
	<xs:complexType name="AmbiguityResolution">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the row child elements must agree with numberOfRows</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="AmbiguityResolutionRow" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="AmbiguityResolutionRow">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="modifier" use="optional" default="max">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="all"/>
					<xs:enumeration value="any"/>
					<xs:enumeration value="avg"/>
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--TimeDomain: proposal-->
	<xs:complexType name="TimeDomain">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element name="interval" type="TimeDomainInterval">
				<xs:annotation>
					<xs:documentation>experimental</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="TimeDomainInterval">
		<xs:attribute name="start" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="horizon" type="xs:double" use="optional" default="INF"/>
	</xs:complexType>
	<xs:complexType name="TimeStages">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of stages must agree with numberOfStages</xs:documentation>
			</xs:annotation>
			<xs:element name="stage" type="TimeStage" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation> </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfStages" type="xs:positiveInteger" use="required"/>
		<!-- not needed here (?)
		<xs:attribute name="decisionEventSequence">
			<xs:annotation>
				<xs:documentation>used for time-staged decomposition</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="decisionBeforeEvent"/>
					<xs:enumeration value="decisionAfterEvent"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
-->
	</xs:complexType>
	<xs:complexType name="TimeStage">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="TimeStageVariables-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="TimeStageObjectives-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="TimeStageConstraints-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="TimeStageMatrixVariables-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="TimeStageMatrixObjectives-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="TimeStageMatrixConstraints-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="TimeStageComplexVariables-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="TimeStageComplexObjectives-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="TimeStageComplexConstraints-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorVariables" type="TimeStageTensorVariables-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorObjectives" type="TimeStageTensorObjectives-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume ALL objectives are included</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorConstraints" type="TimeStageTensorConstraints-2016-Dec-23" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. If missing, assume numberOfConstraints=0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="eventsFollowDecisions" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>events and decisions can share a stage. By default events precede all decisions in a stage. This attribute can be used to reverse the order. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageVariables-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfVar otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageConstraints-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfCon otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageObjectives-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfObj otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:negativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageMatrixVariables-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfMatrixVar otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="matrixVar" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageMatrixVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageMatrixConstraints-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfMatrixCon otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="matrixCon" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageMatrixCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageMatrixObjectives-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfMatrixObj otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="matrixObj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:negativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageMatrixObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageComplexVariables-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfVar otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageComplexVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageComplexConstraints-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfCon otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageComplexCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageComplexObjectives-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfObj otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:negativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageComplexObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="TimeStageTensorVariables-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfTensorVar otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfTensorVar" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageTensorVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageTensorConstraints-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfTensorCon otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="SizelessNonNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfTensorCon" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:nonNegativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageTensorCon">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:int"/>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TimeStageTensorObjectives-2016-Dec-23">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:annotation>
				<xs:documentation>List must be empty if startIdx is used and must match numberOfTensorObj otherwise</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="SizelessNegativeIntVector" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfTensorObj" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="startIdx" type="xs:negativeInteger" use="optional"/>
	</xs:complexType>
	<xs:complexType name="TimeDomainStageTensorObj">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
	</xs:complexType>
	<!--RobustOptimization: proposal-->
	<xs:complexType name="RobustOptimization">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="uncertaintySets" type="UncertaintySets" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UncertaintySets-save">
		<xs:sequence>
			<xs:element name="uncertaintySet" type="UncertaintySet" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfUncertaintySets" use="required"/>
	</xs:complexType>
	<!--StochasticInformation: proposal-->
	<xs:complexType name="StochasticData">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="stochasticElements" type="StochasticElements" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="eventTree" type="StochasticEventTree" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StochasticEventTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="scenarioTree" type="StochasticScenarioTree">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nodalTree" type="StochasticNodalTree">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="implicitTree" type="StochasticImplicitTree">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StochasticScenarioTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the scenario child elements  (including the root scenario) must match numberOfScenarios</xs:documentation>
			</xs:annotation>
			<xs:element name="rootScenario" type="StochasticScenarioTreeRootScenario">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenario" type="StochasticScenarioTreeScenario" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfScenarios" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticScenarioTreeRootScenario">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="StochasticNumbers">
				<xs:attribute name="name" type="xs:string" use="optional"/>
				<xs:attribute name="prob" type="Probability" use="required"/>
				<xs:attribute name="base" use="optional" default="coreProgram">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="coreProgram"/>
							<xs:enumeration value="none"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="stage" type="xs:nonNegativeInteger" use="optional" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticScenarioTreeScenario">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="StochasticNumbers">
				<xs:attribute name="name" type="xs:string" use="optional"/>
				<xs:attribute name="prob" type="Probability" use="required"/>
				<xs:attribute name="parent" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="stage" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticNodalTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the sNode child elements must match numberOfNodes</xs:documentation>
			</xs:annotation>
			<xs:element ref="sNode"/>
		</xs:sequence>
		<xs:attribute name="numberOfNodes" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticImplicitTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="randomVariables" type="StochasticRandomVariables">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearTransformation" type="StochasticLinearTransformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearTransformations" type="StochasticNonlinearTransformations" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="randomFunctions" type="StochasticRandomFunctions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StochasticRowModifers">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of row child elements must match numberOfRows</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="StochasticRowModifier" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticRowModifier">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<xs:attribute name="modifier" use="optional" default="all">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="all"/>
					<xs:enumeration value="any"/>
					<xs:enumeration value="avg"/>
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="StochasticRandomFunctions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number must match numberOfRandomFunctions</xs:documentation>
			</xs:annotation>
			<xs:element name="randomFunction" type="StochasticRandomFunction" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRandomFunctions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticRandomVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of distr child elements must match numberOfDistributions</xs:documentation>
			</xs:annotation>
			<xs:element name="distr" type="StochasticDistribution" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfDistributions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<!--
	<xs:complexType name="StochasticDistribution">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="univariate" type="StochasticUnivariateDistribution"/>
			<xs:element name="multivariate" type="StochasticMultivariateDistribution"/>
		</xs:choice>
		<xs:attribute name="name" type="xs:string" use="optional"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
-->
	<xs:complexType name="StochasticDistribution">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:group ref="DistributionGroup"/>
			<!-- Superseded by CustomDistribution			
			<xs:element ref="generalUnivariateDistribution"/>
			<xs:element name="userF" type="StochasticUnivariateDistributionUserFunction"/>
-->
			<xs:group ref="DistributionTransformationGroup"/>
			<xs:element ref="custom"/>
		</xs:choice>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="StochasticUnivariateDistribution">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:group ref="DistributionGroup"/>
			<!-- Superseded by CustomDistribution			
			<xs:element ref="generalUnivariateDistribution"/>
			<xs:element name="userF" type="StochasticUnivariateDistributionUserFunction"/>
-->
			<xs:group ref="DistributionTransformationGroup"/>
			<xs:element ref="custom"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="StochasticUnivariateDistributionUserFunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="cdf" type="StochasticUnivariateDistributionUserFunctionTree" minOccurs="0"/>
			<xs:element name="pdf" type="StochasticUnivariateDistributionUserFunctionTree" minOccurs="0"/>
			<xs:element name="rng" type="StochasticUnivariateDistributionUserFunctionTree" minOccurs="0"/>
		</xs:choice>
		<xs:attribute name="name" type="xs:IDREF" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticUnivariateDistributionUserFunctionTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StochasticMultivariateDistribution">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:group ref="MultivariateDistributionGroup"/>
			<xs:element ref="generalMultivariateDistribution"/>
			<xs:element name="userF" type="StochasticMultivariateDistributionUserFunction"/>
		</xs:choice>
		<xs:attribute name="numberOfDimensions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticMultivariateDistributionUserFunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="cdf" type="StochasticMultivariateDistributionUserFunctionTree"/>
			<xs:element name="pdf" type="StochasticMultivariateDistributionUserFunctionTree"/>
			<xs:element name="rng" type="StochasticMultivariateDistributionUserFunctionTree"/>
		</xs:choice>
		<xs:attribute name="name" type="xs:IDREF" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticMultivariateDistributionUserFunctionTree">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StochasticNonlinearTransformations">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number must match numberOfNonlinearTransformations</xs:documentation>
			</xs:annotation>
			<xs:element name="nonlinearTransformation" type="StochasticNonlinearTransformation" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfNonlinearTransformations" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNonlinearTransformation">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticLinearTransformation">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="StochasticElements">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number must agree with numberOfStElem</xs:documentation>
			</xs:annotation>
			<!--			<xs:element name="stElem" type="UpdateableProblemComponent_test"/>  -->
			<xs:group ref="UpdateableProblemComponent_test"/>
		</xs:choice>
		<xs:attribute name="numberOfStElem" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementParam">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="value"/>
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="type"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="type"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="weight"/>
					<xs:enumeration value="coef"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="varIdx" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="constant"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementEl">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementQTerm">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:integer" use="required"/>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementNumber">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="id" type="xs:string" use="required"/>
				<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticElementConeVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="type"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="baseValue" type="xs:double" use="optional" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticElementDistributionParam">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="basevalue" type="xs:double" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticLinearTransformationMatrixCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="LinearConstraintCoefficients"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticLinearTransformationAutoregressiveTerms">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="historyParameters" type="StochasticLinearTransformationHistoryParameters"/>
			<xs:element name="matrixCoefficients" type="StochasticLinearTransformationMatrixCoefficients"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="StochasticLinearTransformationHistoryParameters">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>number must match numberOfParameters</xs:documentation>
			</xs:annotation>
			<xs:element name="param" type="StochasticNumberParam"/>
			<xs:element name="var" type="StochasticNumberVar"/>
			<xs:element name="obj" type="StochasticNumberObj"/>
			<xs:element name="con" type="StochasticNumberCon"/>
			<xs:element name="el" type="StochasticNumberLinearConstraintCoefficientsEl"/>
			<xs:element name="qTerm" type="StochasticNumberQuadraticCoefficientsQTerm"/>
			<xs:element name="nlNumber" type="StochasticNumberNonlinearExpressionsNumber"/>
			<xs:element name="coneVar" type="StochasticNumberConeVar"/>
		</xs:choice>
		<xs:attribute name="numberOfParameters" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticRandomFunction">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticRandomFunctionRows">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="row" type="xs:int" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumber">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="StochasticNumbers">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="stochasticElements" type="StochasticNumbersStochasticElements" minOccurs="0"/>
			<xs:element name="parameters" type="StochasticNumbersParameters" minOccurs="0"/>
			<xs:element name="variables" type="StochasticNumbersVariables" minOccurs="0"/>
			<xs:element name="objectives" type="StochasticNumbersObjectives" minOccurs="0"/>
			<xs:element name="constraints" type="StochasticNumbersConstraints" minOccurs="0"/>
			<xs:element name="linearConstraintCoefficients" type="StochasticNumbersLinearConstraintCoefficients" minOccurs="0"/>
			<xs:element name="quadraticCoefficients" type="StochasticNumbersQuadraticCoefficients" minOccurs="0"/>
			<xs:element name="nonlinearExpressions" type="StochasticNumbersNonlinearExpressions" minOccurs="0"/>
		</xs:all>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersParameters">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfParam</xs:documentation>
			</xs:annotation>
			<xs:element name="param" type="StochasticNumberParam" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfParam" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberParam">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersStochasticElements">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="st" type="StochasticNumberStochasticElement" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberStochasticElement">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersVariables">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="var" type="StochasticNumberVar" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lb"/>
							<xs:enumeration value="ub"/>
							<xs:enumeration value="lbAndUb"/>
							<xs:enumeration value="type"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="obj" type="StochasticNumberObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberObj">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:negativeInteger" use="optional" default="-1"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="constant"/>
							<xs:enumeration value="weight"/>
							<xs:enumeration value="coef"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="varIdx" type="xs:nonNegativeInteger" use="optional"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="con" type="StochasticNumberCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberCon">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lb"/>
							<xs:enumeration value="ub"/>
							<xs:enumeration value="lbAndUb"/>
							<xs:enumeration value="constant"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersLinearConstraintCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="el" type="StochasticNumberLinearConstraintCoefficientsEl" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberLinearConstraintCoefficientsEl">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersQuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="StochasticNumberQuadraticCoefficientsQTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberQuadraticCoefficientsQTerm">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:integer" use="required"/>
				<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumbersNonlinearExpressions">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number must match numberOfValues</xs:documentation>
			</xs:annotation>
			<xs:element name="number" type="StochasticNumberNonlinearExpressionsNumber" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfValues" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticNumberNonlinearExpressionsNumber">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="id" type="xs:string" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumberConeVar">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="attr" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lb"/>
							<xs:enumeration value="ub"/>
							<xs:enumeration value="lbAndUb"/>
							<xs:enumeration value="type"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticNumberGeneric">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
				<xs:attribute name="name" type="xs:string" use="optional"/>
				<xs:attribute name="documentation" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticScenarioNode" mixed="false">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:element name="scenarioNode" type="StochasticScenarioNode" abstract="true">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="sNode" type="StochasticNode" substitutionGroup="scenarioNode">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="StochasticNode">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="StochasticScenarioNode">
				<xs:sequence minOccurs="0" maxOccurs="unbounded">
					<xs:choice minOccurs="0">
						<xs:element ref="osil"/>
						<xs:element name="changes" type="StochasticNumbers"/>
					</xs:choice>
					<xs:element ref="scenarioNode" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="prob" type="Probability" use="required"/>
				<xs:attribute name="base" use="optional" default="coreProgram">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="none"/>
							<xs:enumeration value="coreProgram"/>
							<xs:enumeration value="firstSibling"/>
							<xs:enumeration value="lastSibling"/>
							<xs:enumeration value="parent"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="linkingStages" type="xs:nonNegativeInteger" default="0">
					<xs:annotation>
						<xs:documentation>number of past nodes in the tree that enter the linking constraints</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="new_StochasticData">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="uriAliases" type="RealTimeDataURIAliases" minOccurs="0">
				<xs:annotation>
					<xs:documentation>recommendation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="defaultRefreshPoint" type="RefreshPointEnum" default="onOptimizationStart" minOccurs="0"/>
			<xs:element name="new_stochasticDataItem" type="new_StochasticDataItem" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfDataItems</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDataItems" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="new_StochasticDataItem">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="distIdx" type="xs:nonNegativeInteger"/>
			<xs:element name="randomElement" type="RandomElement" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfRandomElements</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="refreshPoint"/>
		<xs:attribute name="numberOfRandomElements" use="required"/>
	</xs:complexType>
	<xs:complexType name="RandomElement">
		<xs:sequence>
			<xs:element name="idx" type="xs:nonNegativeInteger"/>
			<xs:element name="targetComponent" type="UpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTargetComponents</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfTargetComponents" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="new_StochasticDataElement">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="value" type="xs:ID" use="required"/>
				<xs:attribute name="type" use="optional" default="string">
					<xs:annotation>
						<xs:documentation>default is "real"</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="string"/>
							<xs:enumeration value="link"/>
							<xs:enumeration value="real"/>
							<xs:enumeration value="integer"/>
							<xs:enumeration value="xPath"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- A new way of looking at stochastics by building on existing constructs -->
	<xs:complexType name="StochasticData_mark3">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="stochasticDataSource_mark3" type="StochasticDataSource_mark3" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with  numberOfDataItems</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfDataSources" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticDataSource_mark3">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="dataPoint" type="StochasticDataPoint_mark3" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="numberOfDataPoints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticDataPoint_mark3">
		<xs:annotation>
			<xs:documentation>number must agree with numberOfDataPoints</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="targetComponent" type="TargetComponent_mark3" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfTargetComponents</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="arma" type="StochasticDataARMA_mark3" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="numberOfTargetComponents" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="distributionIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="linkMatrixIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>if missing, assume identity matrix (error if dimension mismatch)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="TargetComponent_mark3">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:group ref="UpdateableProblemComponent_test"/>
		</xs:sequence>
		<xs:attribute name="constant" type="xs:double" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="StochasticDataElement_mark3">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="value" type="xs:ID" use="required"/>
				<xs:attribute name="type" use="optional" default="string">
					<xs:annotation>
						<xs:documentation>default is "real"</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="string"/>
							<xs:enumeration value="link"/>
							<xs:enumeration value="real"/>
							<xs:enumeration value="integer"/>
							<xs:enumeration value="xPath"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="StochasticDataARMA_mark3">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ARTerm" type="AutoRegressiveTerm" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfARTerms</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MATerm" type="MovingAverageTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfARTerms" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="numberOfMATerms" type="xs:nonNegativeInteger" use="optional" default="0"/>
	</xs:complexType>
	<xs:complexType name="AutoRegressiveTerm">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:attribute name="order" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="distIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="coefMtxIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="MovingAverageTerm">
		<xs:annotation>
			<xs:documentation>finalization</xs:documentation>
		</xs:annotation>
		<xs:attribute name="lag" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="varRefMtxIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="coefMtxIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="StochasticData-2016-10-05">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="implicitTree" type="ImplicitTree-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="scenarioTree" type="ScenarioTree-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!--			
			<xs:element name="nodalTree" type="NodalTree-2016-11-24" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="nodalTree-2016-12-26" type="NodalTree-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ScenarioTree-2016-10-05">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="timeStages" type="TimeStages" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticElements" type="UpdateableProblemComponent" minOccurs="0">
				<xs:annotation>
					<xs:documentation>number of children must agree with numberOfStochasticElements</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="rootScenario" type="RootScenario-2016-10-05"/>
			<xs:element name="scenario" type="Scenario-2016-10-05" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfScenarios" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfStochasticElements" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mode" default="replace">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="replace"/>
					<xs:enumeration value="add"/>
					<xs:enumeration value="multiply"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RootScenario-2016-10-05">
		<xs:sequence>
			<xs:element name="changesFromCore" type="ChangesInScenario" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="prob" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:double">
					<xs:minInclusive value="0"/>
					<xs:maxInclusive value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="numberOfChanges" type="xs:nonNegativeInteger" default="0"/>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="ChangesInScenario">
		<xs:sequence>
			<xs:element name="idx" type="SizelessNonNegativeIntVector">
				<xs:annotation>
					<xs:documentation>index refers to location within list of stochastic elements. Size of vector must agree with numberOfChanges</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="value" type="SizelessDoubleVector">
				<xs:annotation>
					<xs:documentation>size of vector must agree with numberOfChanges</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="Scenario-2016-10-05">
		<xs:sequence>
			<xs:element name="changesFromParentOrBase" type="ChangesInScenario" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="parent" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="prob" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:double">
					<xs:minInclusive value="0"/>
					<xs:maxInclusive value="1"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="base" type="xs:nonNegativeInteger"/>
		<xs:attribute name="stage" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfChanges" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>changes are relative to parent or, if present, the base scenario</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="name" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="NodalTree-2016-10-05">
		<xs:complexContent>
			<xs:extension base="StochasticNodalTree-2016-10-05"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticNodalTree-2016-10-05">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the sNode child elements must match numberOfNodes</xs:documentation>
			</xs:annotation>
			<xs:element name="rootNode" type="RootNode-2016-10-05"/>
		</xs:sequence>
		<xs:attribute name="numberOfNodes" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RootNode-2016-10-05">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="StochasticScenarioNode-2016-10-05">
				<xs:sequence>
					<xs:choice minOccurs="0">
						<xs:element name="nodeData" type="NodeData-2016-10-05"/>
						<xs:element name="changes" type="ModificationsUpdateableProblemComponent_test"/>
						<xs:element name="changes2" type="NodeModifications-2016-10-05"/>
					</xs:choice>
					<xs:element ref="scenarioNode-2016-10-05" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="prob" type="Probability" use="optional" default="1"/>
				<xs:attribute name="useCoreData" type="xs:boolean" use="optional" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticNode-2016-10-05">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="StochasticScenarioNode-2016-10-05">
				<xs:sequence>
					<xs:choice minOccurs="0">
						<xs:element name="nodeData" type="NodeData-2016-10-05"/>
						<xs:element name="modifications" type="NodeModifications-2016-10-05"/>
					</xs:choice>
					<xs:element ref="scenarioNode-2016-10-05" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="prob" type="Probability" use="required"/>
				<xs:attribute name="numberOfLinkingStages" type="xs:nonNegativeInteger" default="1">
					<xs:annotation>
						<xs:documentation>governs the length of the history that can influence the present node as well as the offsets for variable and constraint references</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
			<!--				
				<xs:attribute name="base" use="optional" default="coreProgram">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="none"/>
							<xs:enumeration value="coreProgram"/>
							<xs:enumeration value="firstSibling"/>
							<xs:enumeration value="lastSibling"/>
							<xs:enumeration value="parent"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
-->
			<!--				
				<xs:attribute name="nodeId" type="xs:ID">
					<xs:annotation>
						<xs:documentation>can be used to provide a reference for later inheritance of data</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="nodeRef" type="xs:IDREF">
					<xs:annotation>
						<xs:documentation>can be used to reference another node in the tree from which the current node inherits data</xs:documentation>
					</xs:annotation>
				</xs:attribute>
-->
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticScenarioNode-2016-10-05" mixed="false">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:element name="scenarioNode-2016-10-05" type="StochasticScenarioNode-2016-10-05" abstract="true">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:element name="sNode-2016-10-05" type="StochasticNode-2016-10-05" substitutionGroup="scenarioNode-2016-10-05">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="NodalTree-2016-11-24">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the nodes in this tree must match numberOfNodes</xs:documentation>
			</xs:annotation>
			<xs:element name="rootNode" type="RootNode-2016-11-24"/>
		</xs:sequence>
		<xs:attribute name="numberOfNodes" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTree-2016-12-26">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the nodes in this tree must match numberOfNodes</xs:documentation>
			</xs:annotation>
			<xs:element name="rootNode" type="RootNode-2016-11-24"/>
		</xs:sequence>
		<xs:attribute name="numberOfNodes" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="RootNode-2016-11-24">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="sNode-2016-11-24">
				<xs:attribute name="prob" type="Probability" use="optional" default="1"/>
				<xs:attribute name="useCoreData" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>must be present if nodeData element is missing; if useCoreData is TRUE, ignore nodeData if present</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="StochasticNode-2016-11-24">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="sNode-2016-11-24">
				<xs:attribute name="prob" type="Probability" use="required"/>
				<xs:attribute name="numberOfLinkingStages" type="xs:nonNegativeInteger" default="1">
					<xs:annotation>
						<xs:documentation>governs the length of the history that can influence the present node as well as the offsets for variable and constraint references</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="sNode-2016-11-24" mixed="false">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element name="nodeData" type="NodeData-2016-10-05">
					<xs:annotation>
						<xs:documentation>nodal trees use local indexing for variables and constraints. To refer to variables or constraints in past tree nodes use the attribute 'lag'.
Experiment.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="modifications" type="NodeModifications-2016-12-26"/>
			</xs:choice>
			<xs:element name="sNode" type="StochasticNode-2016-11-24" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="nodeID" type="xs:ID">
			<xs:annotation>
				<xs:documentation>used to provide a reference for later inheritance of data</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="scenarioNode-2016-11-24" type="sNode-2016-11-24" abstract="true">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="NodeData-2016-10-05">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="variables" type="Variables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0. The indexing is cumulative; current node indices are added after the indices of the variables in the linking ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectiveCoefficients" type="NodalObjectiveCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>to add objective coefficients for variables in the currrent node into previously defined objectives</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additionalObjectives" type="Objectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>the indexing is cumulative. additional objectives are added below the indices of previously defined objectives.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="Constraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0. The indexing is cumulative; current node indices are added after the indices of the constraints in the linking ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="NodalLinearConstraintCoefficients-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>includes matrices on and below the diagonal. Variable indices are offset by the variables in the linking ancestor nodes</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="NodalQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0 - Does not use matrices. So, e.g. the expression 2x + 3y + x^2 + 2xy + 3y^2 has three quadratic coefficients: 1, 2, 3</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="NodalTreeNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 1.0. The indexing is cumulative; current node indices are added after the indices of the expressions in the linking ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="specialOrderedSets" type="SpecialOrderedSets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0
We use the LPSOLVE definition of SOS, which goes back to a paper by J.A.Tomlin in "Studies on Graphs and Discrete Programming", 1981. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexProgramming" type="ComplexProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixProgramming" type="MatrixProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0. The indexing is cumulative; current node indices are added after the indices of the ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="tensorProgramming" type="TensorProgramming" minOccurs="0">
				<xs:annotation>
					<xs:documentation>since version 2.0. The indexing is cumulative; current node indices are added after the indices of the ancestor nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="disjunctiveInformation" type="DisjunctiveInformation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="parameters" type="Parameters" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="uncertaintySets" type="UncertaintySets" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="stochasticData-2016-10-05" type="StochasticData-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="softConstraints" type="SoftConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ambiguityResolution" type="AmbiguityResolution" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="modifications" type="InstanceModifications" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="realTimeData" type="RealTimeData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="userFunctions" type="UserFunctions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="simulations" type="Simulations" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
			<!--
			<xs:element name="updateableData" type="UpdateableData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>realTimeData and simulations. experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
-->
			<xs:element name="new_simulations" type="new_Simulations" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="xmlData" type="XMLData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>finalization</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalObjectiveCoefficients">
		<xs:sequence>
			<xs:element name="obj" type="NodalObjective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalObjective">
		<xs:sequence>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:negativeInteger" default="-1"/>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalQuadraticCoefficients">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the qTerm child elements must agree with numberOfQuadraticTerms </xs:documentation>
			</xs:annotation>
			<xs:element name="qTerm" type="NodalQuadraticTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfQuadraticTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalQuadraticTerm">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of the constraint or objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxModifier" type="xs:string">
			<xs:annotation>
				<xs:documentation>completes the index reference if idxType is not 'local'. For 'lag' and 'stage' must evaluate to a nonnegative integer; for 'node' must be a valid IDREF.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the first variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOneType" type="NodalTreeIndexType" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxOneModifier" type="xs:string">
			<xs:annotation>
				<xs:documentation>completes the index reference if idxOneType is not 'local'. For 'lag' and 'stage' must evaluate to a nonnegative integer; for 'node' must be a valid IDREF.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>index of the second variable</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwoType" type="NodalTreeIndexType" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxTwoModifier" type="xs:string">
			<xs:annotation>
				<xs:documentation>completes the index reference if idxTwoType is not 'local'. For 'lag' and 'stage' must evaluate to a nonnegative integer; for 'node' must be a valid IDREF.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="coef" type="xs:double" use="optional" default="1">
			<xs:annotation>
				<xs:documentation>coefficient of the
quadratic term</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalLinearConstraintCoefficients-2016-12-26">
		<xs:sequence>
			<xs:element name="block" type="NodalLinearConstraintCoefficientBlock-2016-12-26" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalLinearConstraintCoefficientBlock-2016-12-26">
		<xs:complexContent>
			<xs:extension base="LinearConstraintCoefficients">
				<xs:attribute name="lag" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="laggedConstraints" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>by default, variables are lagged. If laggedConstraints is TRUE, then constraints are lagged instead.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeNonlinearExpressions">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the child nl elements must agree with numberOfNonlinearExpressions</xs:documentation>
			</xs:annotation>
			<xs:element name="nl" type="NodalTreeNl" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>shape attribute added in version 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfNonlinearExpressions" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeNl">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element ref="OSnLNode"/>
			<xs:element name="TimeStagedVariable"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required">
			<xs:annotation>
				<xs:documentation>index of constraint or objective row</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxType" type="NodalTreeIndexType" default="local">
			<xs:annotation>
				<xs:documentation>The value of this attribute must be one of "local" (the default), "lag", "stage" (an absolute reference to the number of the stage --- starting from 0 for the root), or "node" (an absolute reference to the ID given to another node).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="idxModifier" type="xs:string">
			<xs:annotation>
				<xs:documentation>completes the index reference if idxType is not 'local'. For 'lag' and 'stage' must evaluate to a nonnegative integer; for 'node' must be a valid IDREF.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="shape" default="unknown">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="linear"/>
					<xs:enumeration value="quadratic"/>
					<xs:enumeration value="convex"/>
					<xs:enumeration value="concave"/>
					<xs:enumeration value="general"/>
					<xs:enumeration value="unknown"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodeModifications-2016-10-05">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="substitutions" type="ModificationUpdates_test" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="deletions" type="NodalTreeModificationDeletions-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additions" type="NodalTreeModificationAdditions-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodeModifications-2016-12-26">
		<xs:annotation>
			<xs:documentation>experiment </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="substitutions" type="NodalTreeModificationUpdates-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="deletions" type="NodalTreeModificationDeletions-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="additions" type="NodalTreeModificationAdditions-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="baseRef" type="xs:IDREF">
			<xs:annotation>
				<xs:documentation>used to identify another node in the tree as a base from which the current node inherits data</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentVariable-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
					<xs:enumeration value="lbAndUb"/>
					<xs:enumeration value="type"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentObjective-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="weight"/>
					<xs:enumeration value="coef"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="varIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>required if attr="coef"</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentConstraint-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="attr" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="constant"/>
					<xs:enumeration value="lb"/>
					<xs:enumeration value="ub"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentLinearConstraintCoefficient-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentQuadraticCoefficient-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:int" use="required"/>
		<xs:attribute name="idxOne" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxTwo" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentNlNode-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:IDREF" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentNlCNode-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="id" type="xs:string" use="required"/>
		<xs:attribute name="part" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="real"/>
					<xs:enumeration value="imaginary"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponentMatrixElement-2016-12-26">
		<xs:annotation>
			<xs:documentation>draft</xs:documentation>
		</xs:annotation>
		<xs:attribute name="matrixIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalUpdateableProblemComponent-2016-12-26">
		<xs:choice>
			<xs:element name="var" type="UpdateableProblemComponentVariable">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="obj" type="UpdateableProblemComponentObjective">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the objective</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="con" type="UpdateableProblemComponentConstraint">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficient" type="NodalTreeUpdateableProblemComponentLinearConstraintCoefficient-2016-12-26">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the constraint matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="qCoef" type="NodalTreeUpdateableProblemComponentQuadraticCoefficient-2016-12-26">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the quadratic expressions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OSnLNode" type="UpdateableProblemComponentNlNode">
				<xs:annotation>
					<xs:documentation>draft - refer to any OSnLNode in any nonlinear expression, including matrix constructs</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixElement" type="UpdateableProblemComponentMatrixElement">
				<xs:annotation>
					<xs:documentation>draft - may NOT change the sparsity pattern of the matrix</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationUpdates-2016-12-26">
		<xs:sequence>
			<xs:element name="subst" type="NodalUpdateableProblemComponent-2016-12-26" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfSubst" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeUpdateableProblemComponentLinearConstraintCoefficient-2016-12-26">
		<xs:complexContent>
			<xs:extension base="UpdateableProblemComponentLinearConstraintCoefficient">
				<xs:attribute name="blockIdx" type="xs:nonNegativeInteger" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeUpdateableProblemComponentQuadraticCoefficient-2016-12-26">
		<xs:complexContent>
			<xs:extension base="UpdateableProblemComponentQuadraticCoefficient">
				<xs:attribute name="rowIdxType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="rowIdxModifier" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="idxOneType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxOneModifier" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="idxTwoType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxTwoModifier" type="xs:nonNegativeInteger" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeletions-2016-12-26">
		<xs:sequence>
			<xs:element name="variables" type="ModificationDeleteVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="ModificationDeleteObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="ModificationDeleteConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintBlocks" type="NodalTreeModificationDeleteLinearConstraintBlocks-2016-12-26" minOccurs="0"/>
			<xs:element name="linearConstraintCoefficients" type="ModificationDeleteLinearConstraintCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="ModificationDeleteQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationDeleteNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="ModificationDeleteMatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="ModificationDeleteMatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="ModificationDeleteMatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="ModificationDeleteMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteVariables-2016-12-26">
		<xs:annotation>
			<xs:documentation>experiment</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="var" type="ModificationDeleteVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a variable, its cost and constraint coefficients, and all quadratic terms and nonlinear expressions in which the variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteVar-2016-12-26">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteObjectives-2016-12-26">
		<xs:sequence>
			<xs:element name="obj" type="ModificationDeleteObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteObj-2016-12-26">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="colIdx">
			<xs:annotation>
				<xs:documentation>If present, delete only the objective coefficient in this column</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteConstraints-2016-12-26">
		<xs:sequence>
			<xs:element name="con" type="ModificationDeleteCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteCon-2016-12-26">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteLinearConstraintBlocks-2016-12-26">
		<xs:sequence>
			<xs:element name="block" type="ModificationDeleteLinearConstraintCoefficients" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteLinearConstraintCoefficients-2016-12-26">
		<xs:sequence>
			<xs:element name="el" type="NodalTreeModificationDeleteLinearConstraintEl-2016-12-26" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteLinearConstraintEl-2016-12-26">
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="blockIdx" type="xs:nonNegativeInteger" default="0"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteQuadraticCoefficients-2016-12-26">
		<xs:sequence>
			<xs:element name="qTerm" type="NodalTreeModificationDeleteQTerm-2016-12-26" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="numberOfQTerms" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteQTerm-2016-12-26">
		<xs:complexContent>
			<xs:extension base="ModificationDeleteQTerm">
				<xs:attribute name="idxType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxModifier" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="idxOneType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxOneModifier" type="xs:nonNegativeInteger" default="0"/>
				<xs:attribute name="idxTwoType" type="NodalTreeIndexType" default="local"/>
				<xs:attribute name="idxTwoModifier" type="xs:nonNegativeInteger" default="0"/>
			</xs:extension>
		</xs:complexContent>
		<!--
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="idxOne" use="required"/>
		<xs:attribute name="idxTwo" use="required"/>
-->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteNonlinearExpressions-2016-12-26">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="nl" type="ModificationDeleteNl"/>
		</xs:sequence>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteNl-2016-12-26">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixVariables-2016-12-26">
		<xs:sequence>
			<xs:element name="matrixVar" type="ModificationDeleteMatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>delete a matrix variable and all terms in all nonlinear and matrix expressions in which the matrix variable occurs.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixVar-2016-12-26">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixObjectives-2016-12-26">
		<xs:sequence>
			<xs:element name="matrixObj" type="ModificationDeleteMatrixObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixObj-2016-12-26">
		<xs:attribute name="idx" type="xs:negativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixConstraints-2016-12-26">
		<xs:sequence>
			<xs:element name="matrixCon" type="ModificationDeleteMatrixCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixCon-2016-12-26">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="mult" type="xs:nonNegativeInteger" default="1"/>
		<xs:attribute name="incr" type="xs:nonNegativeInteger" default="1"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixExpressions-2016-12-26">
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="expr" type="ModificationDeleteMatrixExpr"/>
		</xs:sequence>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationDeleteMatrixExpr-2016-12-26">
		<xs:attribute name="idx" type="xs:int" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAdditions-2016-12-26">
		<xs:sequence>
			<xs:element name="variables" type="ModificationAddVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectiveCoefficients" type="ModificationAddObjectiveCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add objective coeffficients into existing objectves</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="objectives" type="ModificationAddObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment. To add new objectives and their coefficientss</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="constraints" type="ModificationAddConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintCoefficients" type="NodalTreeModificationAddLinearConstraintCoefficients-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment
To add coefficients one at a time</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="linearConstraintBlocks" type="NodalTreeModificationAddLinearConstraintBlocks-2016-12-26" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment
To add entire coefficient blocks more efficiently</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="quadraticCoefficients" type="ModificationAddQuadraticCoefficients" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="nonlinearExpressions" type="ModificationAddNonlinearExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixVariables" type="ModificationAddMatrixVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixObjectives" type="ModificationAddMatrixObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixConstraints" type="ModificationAddMatrixConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="matrixExpressions" type="ModificationAddMatrixExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexVariables" type="ModificationAddComplexVariables" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexObjectives" type="ModificationAddComplexObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexConstraints" type="ModificationAddComplexConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="complexExpressions" type="ModificationAddComplexExpressions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>experiment</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddVariables-2016-12-26">
		<xs:sequence>
			<xs:element name="var" type="Variable" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfVariables" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddObjectiveCoefficients-2016-12-26">
		<xs:sequence>
			<xs:element name="obj" type="ModificationAddObjective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddObjective-2016-12-26">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>number of coef child elements must match numberOfObjCoef</xs:documentation>
			</xs:annotation>
			<xs:element name="coef" type="ObjCoef" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>If idx is repeated, the objective terms/coefficients are added together.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:negativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>must refer to a previously existing objective</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfObjCoef" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddObjCoef-2016-12-26">
		<xs:annotation>
			<xs:documentation>since version 1.0</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:double">
				<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddObjectives-2016-12-26">
		<xs:sequence>
			<xs:element name="obj" type="Objective" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddConstraints-2016-12-26">
		<xs:sequence>
			<xs:element name="con" type="Constraint" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddLinearConstraintCoefficients-2016-12-26">
		<xs:sequence>
			<xs:element name="el" type="NodalTreeModificationAddLinearConstraintEl-2016-12-26" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfEl" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddLinearConstraintEl-2016-12-26">
		<xs:attribute name="colIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="blockIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="value" type="xs:double" default="0.0"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddLinearConstraintBlocks-2016-12-26">
		<xs:sequence>
			<xs:element name="block" type="NodalLinearConstraintCoefficientBlock-2016-12-26" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddQuadraticCoefficients-2016-12-26">
		<xs:sequence>
			<xs:element name="qTerm" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddNonlinearExpressions-2016-12-26">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="nl" type="NodalTreeModificationAddNl-2016-12-26"/>
		</xs:choice>
		<xs:attribute name="numberOfNl" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddNl-2016-12-26">
		<xs:choice maxOccurs="unbounded">
			<xs:element ref="OSnLNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddMatrixVariables-2016-12-26">
		<xs:sequence>
			<xs:element name="matrixVar" type="MatrixVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddMatrixObjectives-2016-12-26">
		<xs:sequence>
			<xs:element name="matrixObj" type="MatrixObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixObj" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddMatrixConstraints-2016-12-26">
		<xs:sequence>
			<xs:element name="matrixCon" type="MatrixCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfMatrixCon" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddMatrixExpressions-2016-12-26">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="NodalTreeModificationAddMatrixExpr-2016-12-26"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddMatrixExpr-2016-12-26">
		<xs:choice maxOccurs="unbounded">
			<xs:element ref="OSnLMNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddComplexVariables-2016-12-26">
		<xs:sequence>
			<xs:element name="complexVar" type="ComplexVar" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>since version 1.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfComplexVar" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddComplexObjectives-2016-12-26">
		<xs:sequence>
			<xs:element name="complexObj" type="ComplexObj" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfObjectives" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddComplexConstraints-2016-12-26">
		<xs:sequence>
			<xs:element name="con" type="ComplexCon" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfConstraints" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddComplexExpressions-2016-12-26">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="number" type="xs:string"/>
			<xs:element name="string" type="xs:string"/>
			<xs:element name="expr" type="NodalTreeModificationAddComplexExpr-2016-12-26"/>
		</xs:choice>
		<xs:attribute name="numberOfExpr" type="xs:nonNegativeInteger" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="NodalTreeModificationAddComplexExpr-2016-12-26">
		<xs:choice maxOccurs="unbounded">
			<xs:element ref="OSnLCNode"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:int" use="required"/>
		<!--		<xs:attribute name="modificationType" type="ModificationType" use="optional" default="update"/>  -->
	</xs:complexType>
	<xs:complexType name="ImplicitTree-2016-10-05">
		<xs:sequence>
			<xs:element name="timeStages" type="TimeStages" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="block" type="ImplicitTreeBlock-2016-10-05" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfBlocks.
The random variables referened by distributionIdx are independent from one block to another.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="softConstraints" type="SoftConstraints-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>draft</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="probabilisticObjectives" type="SoftConstraintsProbabilisticObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfBlocks" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="ambiguityResolution">
			<xs:annotation>
				<xs:documentation>default is "max" for minimization problems, "min" for maximization problems</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="any"/>
					<xs:enumeration value="all"/>
					<xs:enumeration value="avg"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="min"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImplicitTreeBlock-2016-10-05">
		<xs:sequence>
			<xs:element name="stochEl" type="UpdateableProblemComponent" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfStochEl</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ar" type="AutoRegressiveComponent-2016-10-05" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfAR. 
Each term adds rows to the input vector for the transformation, first the random variable or vector, followed by any references to stochEl.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ma" type="AR-2016-10-05" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfMA. Each moving average term refers to a previously set decision variable, matrix variable, etc. Each reference adds one or more rows to the input vector of the transformation</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="transformation" type="ImplicitTreeStochasticTransformation-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>the transformation forms a flattened column vector of current observations and autoregressive terms and moving average terms (and perhaps a constant term) and transforms this into the vector of stochastic elements. Any random matrices are expanded column by column. 
Default: identity matrix.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="stageIdx" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>number of the stage in which the information is revealed</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="distributionIdx" use="required">
			<xs:annotation>
				<xs:documentation>gives the index of the distribution in the "distributions" element</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfStochEl" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="numberOfAR" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>autoregressive terms</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfMA" type="xs:nonNegativeInteger" default="0">
			<xs:annotation>
				<xs:documentation>moving average terms</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImplicitTreeStochasticTransformation-2016-10-05">
		<xs:complexContent>
			<xs:extension base="StochasticLinearTransformation">
				<xs:attribute name="mtxIdx" type="xs:nonNegativeInteger" use="required">
					<xs:annotation>
						<xs:documentation>refers to a matrix in the "matrices" section.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RV-2016-10-05">
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>gives the index of the distribution in the "distributions" element</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="AutoRegressiveComponent-2016-10-05">
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>experiment</xs:documentation>
			</xs:annotation>
			<xs:element name="stochElIdx" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfStochEl. Each index refers back to the list of stochEl in the first definition of this stochastic component</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>gives the index of a previously defined stochastic component ("stoch")</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="numberOfStochEl" type="xs:nonNegativeInteger" default="0"/>
	</xs:complexType>
	<xs:complexType name="AR-2016-10-05">
		<xs:attribute name="idx" type="xs:integer" use="required"/>
		<xs:attribute name="type" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="var"/>
					<xs:enumeration value="matrixVar"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!--SoftConstraints: proposal-->
	<xs:complexType name="SoftConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="penalties" type="SoftConstraintsPenalties" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="probabilisticObjectives" type="SoftConstraintsProbabilisticObjectives" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="chanceConstraints" type="SoftConstraintsChanceConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="integratedChanceConstraints" type="SoftConstraintsIntegratedChanceConstraints" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="userDefinedRiskMeasures" type="SoftConstraintsUserDefinedRiskMeasures" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsPenalties">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the row child elements must match numberOfPenalties</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="SoftConstraintsPenaltiesRow" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfPenalties" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsPenaltiesRow">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element name="simpleRecourse" type="SoftConstraintsSimpleRecourse"/>
			<xs:element name="quadraticPenalty" type="SoftConstraintsQuadraticPenalty"/>
			<xs:element name="userDefinedPenalty" type="SoftConstraintsUserDefinedPenalty"/>
			<xs:element name="chanceConstraint" type="SoftConstraintsSimpleChanceConstraint"/>
			<xs:element name="integratedChanceConstraint" type="SoftConstraintsSimpleIntegratedChanceConstraint"/>
		</xs:choice>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="objectiveIdx" type="xs:negativeInteger" use="optional" default="-1"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleRecourse">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="shortagePenalty" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="surplusPenalty" type="xs:double" use="optional" default="0"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsRobustOptimization">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="quadraticShortagePenalty" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="quadraticSurplusPenalty" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="quadraticFactor" type="PositiveDouble" use="optional" default="2.0"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsQuadraticPenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="linearShortageParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="linearSurplusParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="quadraticShortageParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="quadraticSurplusParam" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="piecewiseLinearQuadratic" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>if true, sets up Rockafellar's piecewise linear-quadratic penalties</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedPenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="surplusPenalty" type="SoftConstraintsUserDefinedSurplusPenalty" minOccurs="0"/>
			<xs:element name="shortagePenalty" type="SoftConstraintsUserDefinedShortagePenalty" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="name" type="xs:ID" use="required"/>
		<xs:attribute name="default" type="xs:string" use="optional"/>
		<xs:attribute name="isVariable" type="xs:boolean" use="optional" default="false"/>
		<xs:attribute name="variableType" type="GeneralEnumerationVarType" use="optional" default="C"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedSurplusPenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element ref="OSnLNode" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedShortagePenalty">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element ref="OSnLNode" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsProbabilisticObjectives">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of the probabilisticObjective child elements (simple or joint) must match numberOfProbabilisticObjectives</xs:documentation>
			</xs:annotation>
			<xs:element name="simpleProbabilisticObjective" type="SoftConstraintsSimpleProbabilisticObjective" minOccurs="0"/>
			<xs:element name="jointProbabilisticObjective" type="SoftConstraintsJointProbabilisticObjective" minOccurs="0"/>
		</xs:choice>
		<xs:attribute name="numberOfProbabilisticObjectives" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleProbabilisticObjective">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="maxOrMin" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointProbabilisticObjective">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the row child elements must match numberOfRows</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="SoftConstraintsConstraintRow" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="maxOrMin" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="aggregatingFunction" use="optional" default="and">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="sum"/>
					<xs:enumeration value="and"/>
					<xs:enumeration value="or"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsChanceConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of the chanceConstraint child elements (simple or joint) must match numberOfChanceConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="simpleChanceConstraint" type="SoftConstraintsSimpleChanceConstraint" minOccurs="0"/>
			<xs:element name="jointChanceConstraint" type="SoftConstraintsJointChanceConstraint" minOccurs="0"/>
		</xs:choice>
		<xs:attribute name="numberOfChanceConstraints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="lb" type="Probability" use="optional" default="0.0"/>
		<xs:attribute name="ub" type="Probability" use="optional" default="1.0"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the row child elements must match numberOfRows</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="SoftConstraintsConstraintRow" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="Probability" use="optional" default="0.0"/>
		<xs:attribute name="ub" type="Probability" use="optional" default="1.0"/>
		<xs:attribute name="aggregatingFunction" use="optional" default="and">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="sum"/>
					<xs:enumeration value="and"/>
					<xs:enumeration value="or"/>
					<xs:enumeration value=""/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsIntegratedChanceConstraints">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of the integratedChanceConstraint child elements (simple or joint) must match numberOfIntegratedChanceConstraints</xs:documentation>
			</xs:annotation>
			<xs:element name="simpleIntegratedChanceConstraint" type="SoftConstraintsSimpleIntegratedChanceConstraint" minOccurs="0"/>
			<xs:element name="jointIntegratedChanceConstraint" type="SoftConstraintsJointIntegratedChanceConstraint" minOccurs="0"/>
		</xs:choice>
		<xs:attribute name="numberOfIntegratedChanceConstraints" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleIntegratedChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointIntegratedChanceConstraint">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the row child elements must match numberOfRows</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="SoftConstraintsConstraintRow" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="aggregatingFunction" use="optional" default="and">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="sum"/>
					<xs:enumeration value="and"/>
					<xs:enumeration value="or"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsUserDefinedRiskMeasures">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
				<xs:documentation>Number of the userDefinedRiskMeasure child elements (simple or joint) must match numberOfUserDefinedRiskMeasures</xs:documentation>
			</xs:annotation>
			<xs:element name="simpleUserDefinedRiskMeasure" type="SoftConstraintsSimpleUserDefinedRiskMeasure" minOccurs="0"/>
			<xs:element name="jointUserDefinedRiskMeasure" type="SoftConstraintsJointUserDefinedRiskMeasure" minOccurs="0"/>
		</xs:choice>
		<xs:attribute name="numberOfUserDefinedRiskMeasures" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsSimpleUserDefinedRiskMeasure">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="rowIdx" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointUserDefinedRiskMeasure">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:annotation>
				<xs:documentation>Number of the row child elements must match numberOfRows</xs:documentation>
			</xs:annotation>
			<xs:element name="row" type="SoftConstraintsJointUserDefinedRiskMeasureRow" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute name="lb" type="xs:double" use="optional" default="0"/>
		<xs:attribute name="ub" type="xs:double" use="optional" default="INF"/>
		<xs:attribute name="aggregatingFunction" use="optional" default="and">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="min"/>
					<xs:enumeration value="max"/>
					<xs:enumeration value="sum"/>
					<xs:enumeration value="and"/>
					<xs:enumeration value="or"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsJointUserDefinedRiskMeasureRow">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="OSnLNode" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraintsConstraintRow">
		<xs:annotation>
			<xs:documentation>proposal</xs:documentation>
		</xs:annotation>
		<xs:attribute name="idx" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="SoftConstraints-2016-10-05">
		<xs:sequence>
			<xs:element name="single" type="SingleSoftConstraint-2016-10-05" minOccurs="0">
				<xs:annotation>
					<xs:documentation>proposal</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SoftConstraint-2016-10-05">
		<xs:choice minOccurs="0" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="SingleSoftConstraint-2016-10-05">
		<xs:sequence>
			<xs:element name="con" type="SoftConstraintsPenaltiesRow">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfCon</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="numberOfCon" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:complexType name="JointSoftConstraint-2016-10-05">
		<xs:sequence>
			<xs:element name="row" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>number must agree with numberOfRows</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice>
				<xs:element name="userDefinedPenalty" type="SoftConstraintsUserDefinedPenalty"/>
				<xs:element name="chanceConstraint" type="SoftConstraintsJointChanceConstraint"/>
				<xs:element name="integratedChanceConstraint" type="SoftConstraintsJointIntegratedChanceConstraint"/>
			</xs:choice>
		</xs:sequence>
		<xs:attribute name="objectiveIdx" type="xs:negativeInteger" default="-1"/>
		<xs:attribute name="numberOfRows" type="xs:nonNegativeInteger" use="required"/>
	</xs:complexType>
	<xs:simpleType name="RefreshPointEnum">
		<xs:restriction base="xs:string">
			<xs:annotation>
				<xs:documentation>experiment</xs:documentation>
			</xs:annotation>
			<xs:enumeration value="onSystemStart"/>
			<xs:enumeration value="onServiceStart"/>
			<xs:enumeration value="onJobStart"/>
			<xs:enumeration value="onOptimizationStart"/>
			<xs:enumeration value="onInputChange"/>
			<xs:enumeration value="always"/>
		</xs:restriction>
	</xs:simpleType>
</xs:schema>
